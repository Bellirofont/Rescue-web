<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>PSO MapBY Dfly v4.0 ‚Äî –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; font-family: Arial, sans-serif; overflow: hidden; background: #fff; }
        #map { position: absolute; top: 0; bottom: 0; left: 0; right: 0; width: 100vw; height: 100vh; background: #dddddd; z-index: 1; }
        #sidebar { position: absolute; top: 10px; left: 10px; width: 340px; max-height: 90vh; overflow-y: auto; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 12px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 1000; font-size: 14px; }
        button, input, select { margin: 5px 0; padding: 10px; width: 100%; border-radius: 8px; box-sizing: border-box; border: 1px solid #ccc; font-size: 14px; }
        button { cursor: pointer; font-weight: bold; }
        .primary { background:#4CAF50; color:white; }
        .accent { background:#FF9800; color:white; }
        .danger { background:#f44336; color:white; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
        th, td { border: 1px solid #999; padding: 8px; text-align: center; }
        th { background: #f0f0f0; }
        .grid-label { background: transparent; border: none; color: #000; font-weight: bold; font-size: 12px; text-shadow: 1px 1px 3px white; }
        .group-label { background: rgba(255,255,255,0.9); padding: 4px 10px; border-radius: 6px; font-weight: bold; box-shadow: 0 0 8px rgba(0,0,0,0.3); }
        tr { cursor: pointer; transition: background 0.2s; }
        tr:hover { filter: brightness(0.95); }
    </style>
</head>
<body>
<div id="map"></div>
<div id="sidebar">
    <h2>PSO –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä v4.0 ‚Äî –£–õ–£–ß–®–ï–ù–ù–´–ô</h2>
    <button onclick="clearMap()" class="danger">–û—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ä—Ç—É</button>
    <button onclick="startDrawing()" class="primary">–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –ø–æ–ª–∏–≥–æ–Ω –ø–æ–∏—Å–∫–∞</button>
    <button onclick="saveProject()" class="primary">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–ª–∞–Ω –ø–æ–∏—Å–∫–∞</button>
    <button onclick="loadProject()" class="primary">–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–ª–∞–Ω –ø–æ–∏—Å–∫–∞</button>
    <hr>
    <div id="gridControls" style="display:none;">
        <h4>–ì—Ä–∏–¥</h4>
        <select id="gridPreset">
            <option value="100">100 –º</option>
            <option value="150">150 –º</option>
            <option value="200" selected>200 –º</option>
            <option value="250">250 –º</option>
            <option value="500">500 –º</option>
            <option value="1000">1 –∫–º</option>
        </select>
        <input type="number" id="gridCustom" placeholder="–°–≤–æ—ë (–º)">
        <button onclick="generateGrid()" class="primary">–ù–∞–Ω–µ—Å—Ç–∏ —Å–µ—Ç–∫—É</button>
    </div>
    <hr>
    <h4>–ì—Ä—É–ø–ø—ã</h4>
    <input id="baseCall" placeholder="–ë–∞–∑–∞ (–¢—Ä–µ—Å—Ç)" value="–¢—Ä–µ—Å—Ç">
    <input type="number" id="startNum" placeholder="–°—Ç–∞—Ä—Ç–æ–≤—ã–π ‚Ññ (–ø—É—Å—Ç–æ=–∞–≤—Ç–æ)">
    <input type="number" id="people" placeholder="–õ—é–¥–µ–π" value="5">
    <input type="number" id="cars" placeholder="–ê–≤—Ç–æ" value="0">
    <input type="number" id="blaNum" placeholder="–ë–õ–ê (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ)" value="0">
    <button onclick="addGroup()" class="accent">–î–æ–±–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø—É</button>
    <button onclick="assignZones()" class="danger">–†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∑–æ–Ω—ã</button>
    <table id="groupsTable"><tr><th>–ü–æ–∑—ã–≤–Ω–æ–π</th><th>–õ—é–¥–∏</th><th>–ê–≤—Ç–æ</th><th>–ë–õ–ê</th><th>–ü–ª–æ—â–∞–¥—å –º¬≤</th><th>–ö–≤–∞–¥—Ä–∞—Ç–æ–≤</th></tr></table>
    <hr>
    <h4>–ú–∞—Ä—à—Ä—É—Ç—ã</h4>
    <input type="number" id="stepPesh" placeholder="–®–∞–≥ –ø–µ—à–∏—Ö (–º)" value="10">
    <input type="number" id="stepBla" placeholder="–®–∞–≥ –ë–õ–ê (–º)" value="50">
    <button onclick="generateRoutes()" class="accent">–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç—ã</button>
    <hr>
    <button onclick="exportGeoJSON()">–≠–∫—Å–ø–æ—Ä—Ç GeoJSON</button>
    <button onclick="exportKML()">–≠–∫—Å–ø–æ—Ä—Ç KML</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-kml@1.0.1/L.KML.min.js"></script>

<script>
if (typeof L === 'undefined') {
    alert('Leaflet –ù–ï –ó–ê–ì–†–£–ó–ò–õ–°–Ø ‚Äî –æ—Ç–∫–ª—é—á–∏—Ç–µ adblock, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç!');
} else {
    console.log('Leaflet OK, version:', L.version);
}

document.addEventListener('DOMContentLoaded', () => {
    const map = L.map('map', { 
        doubleClickZoom: false,
        attributionControl: false,
        zoomControl: true
    }).setView([53.90, 27.55], 12);

    if (map.attributionControl) map.attributionControl.remove();
    map.getContainer().style.background = '#dddddd';

    const tileOptions = { attribution: '', maxZoom: 22, maxNativeZoom: 19 };

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', tileOptions).addTo(map);
    const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', tileOptions);
    const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', tileOptions);

    L.control.layers({'OSM': osm, 'ESRI Satellite': esri, 'Google Satellite': googleSat}, {}, {position: 'topright', collapsed: true}).addTo(map);

    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —à–∫–∞–ª–∞ –º–∞—Å—à—Ç–∞–±–∞
    L.control.scale({ position: 'bottomleft', maxWidth: 200 }).addTo(map);

    const forceResize = () => setTimeout(() => map.invalidateSize({pan: true, animate: true}), 50);
    window.addEventListener('resize', forceResize);
    window.addEventListener('orientationchange', forceResize);
    map.whenReady(forceResize);

    const drawnItems = new L.FeatureGroup().addTo(map);
    let searchPolygon = null;
    let searchFeature = null;
    let gridLayer = L.layerGroup().addTo(map);
    let zoneLayers = L.layerGroup().addTo(map);
    let routeLayers = L.layerGroup().addTo(map);
    let roadLayer = L.layerGroup().addTo(map); // –î–ª—è –¥–æ—Ä–æ–≥
    let gridCells = [];
    let groups = [];
    const colors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999','#66c2a5'];

    // Leaflet.draw setup
    const drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
            polygon: {
                allowIntersection: false,
                shapeOptions: {
                    color: '#3388ff',
                    weight: 4,
                    opacity: 1,
                    fillOpacity: 0.2
                }
            },
            polyline: false,
            circle: false,
            rectangle: false,
            marker: false,
            circlemarker: false
        },
        edit: {
            featureGroup: drawnItems,
            remove: false
        }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
        const type = e.layerType;
        const layer = e.layer;

        if (type === 'polygon') {
            console.log('Polygon created');
            if (searchPolygon) {
                drawnItems.removeLayer(searchPolygon);
            }
            searchPolygon = layer;
            searchFeature = searchPolygon.toGeoJSON();
            drawnItems.addLayer(searchPolygon);
            document.getElementById('gridControls').style.display = 'block';
            loadRoads(); // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Ä–æ–≥ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞
            forceResize();
        }
    });

    window.startDrawing = function() {
        if (searchPolygon) {
            drawnItems.removeLayer(searchPolygon);
            searchPolygon = null;
            searchFeature = null;
            document.getElementById('gridControls').style.display = 'none';
        }
        new L.Draw.Polygon(map).enable();
        console.log('Drawing enabled');
    };

    window.clearMap = function() {
        if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ä—Ç—É?')) {
            drawnItems.clearLayers();
            gridLayer.clearLayers();
            zoneLayers.clearLayers();
            routeLayers.clearLayers();
            roadLayer.clearLayers();
            gridCells = [];
            groups = [];
            searchPolygon = null;
            searchFeature = null;
            document.getElementById('gridControls').style.display = 'none';
            updateGroupsTable();
            forceResize();
        }
    };

    const russianLetters = '–ê–ë–í–ì–î–ï–ñ–ó–ò–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–Æ'.split('');

    window.getColumnLabel = function(n) {
        let s = '';
        while (n >= 0) {
            s = russianLetters[n % russianLetters.length] + s;
            n = Math.floor(n / russianLetters.length) - 1;
        }
        return s || '–ê';
    };

    window.generateGrid = function() {
        if (!searchFeature) return alert('–ù–∞—Ä–∏—Å—É–π –ø–æ–ª–∏–≥–æ–Ω!');
        gridLayer.clearLayers();
        gridCells = [];

        let size = parseFloat(document.getElementById('gridCustom').value) || parseFloat(document.getElementById('gridPreset').value);
        if (!size || size <= 0) return alert('–†–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏!');

        const buffered = turf.buffer(searchFeature, 1, {units: 'kilometers'});
        const bbox = turf.bbox(buffered);
        const avgLat = (bbox[1] + bbox[3]) / 2;
        const metersPerDegLat = 111132.92 - 559.82 * Math.cos(2 * avgLat * Math.PI/180) + 1.175 * Math.cos(4 * avgLat * Math.PI/180);
        const metersPerDegLon = 111412.84 * Math.cos(avgLat * Math.PI/180) - 93.5 * Math.cos(3 * avgLat * Math.PI/180);
        const degLat = size / metersPerDegLat;
        const degLon = size / metersPerDegLon;

        let startLon = Math.floor(bbox[0] / degLon) * degLon - degLon;
        let startLat = Math.floor(bbox[1] / degLat) * degLat - degLat;

        let col = 0;
        for (let lon = startLon; lon <= bbox[2] + degLon; lon += degLon) {
            let row = 1;
            for (let lat = startLat; lat <= bbox[3] + degLat; lat += degLat) {
                L.polyline([[lat, lon], [lat, lon + degLon]], {color: '#3388ff', weight: 1}).addTo(gridLayer);
                L.polyline([[lat, lon], [lat + degLat, lon]], {color: '#3388ff', weight: 1}).addTo(gridLayer);

                const label = getColumnLabel(col) + row;
                const icon = L.divIcon({className: 'grid-label', html: label, iconSize: [30,30], iconAnchor: [15,15]});
                L.marker([lat, lon], {icon}).addTo(gridLayer);

                const cellPoly = turf.polygon([[[lon, lat], [lon + degLon, lat], [lon + degLon, lat + degLat], [lon, lat + degLat], [lon, lat]]]);
                let clipped = turf.intersect(cellPoly, searchFeature);
                if (clipped && turf.area(clipped) > 100) {
                    const area = turf.area(clipped);
                    const center = turf.center(clipped); // ‚úÖ –¢–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç GeoJSON Point

                    clipped.properties = {label, area};
                    const layer = L.geoJSON(clipped, {style: {color: '#3388ff', weight: 1, fillOpacity: 0.05}}).addTo(gridLayer);

                    gridCells.push({geojson: clipped, layer, center: center, area});
                }
                row++;
            }
            col++;
        }
        forceResize();
    };

    window.addGroup = function() {
        const base = document.getElementById('baseCall').value.trim() || 'Group';
        let maxNum = 0;
        groups.forEach(g => {
            if (g.callsign.startsWith(base + '-')) {
                const n = parseInt(g.callsign.split('-')[1]);
                if (n > maxNum) maxNum = n;
            }
        });
        let num = document.getElementById('startNum').value ? parseInt(document.getElementById('startNum').value) : maxNum + 1;
        if (isNaN(num) || num < 1) num = maxNum + 1;
        const callsign = `${base}-${num.toString().padStart(2,'0')}`;
        const people = parseInt(document.getElementById('people').value) || 0;
        const cars = parseInt(document.getElementById('cars').value) || 0;
        const bla = parseInt(document.getElementById('blaNum').value) || 0;

        groups.push({callsign, people, cars, bla, color: colors[groups.length % colors.length], cells: [], area: 0});
        updateGroupsTable();
        document.getElementById('startNum').value = '';
    };

    window.updateGroupsTable = function() {
        const table = document.getElementById('groupsTable');
        table.innerHTML = '<tr><th>–ü–æ–∑—ã–≤–Ω–æ–π</th><th>–õ—é–¥–∏</th><th>–ê–≤—Ç–æ</th><th>–ë–õ–ê</th><th>–ü–ª–æ—â–∞–¥—å –º¬≤</th><th>–ö–≤–∞–¥—Ä–∞—Ç–æ–≤</th></tr>';
        groups.forEach(g => {
            const row = table.insertRow();
            row.style.backgroundColor = g.color + '33';
            row.onclick = () => { if (g.cells.length) map.fitBounds(getGroupBounds(g)); };
            row.insertCell().innerText = g.callsign;
            row.insertCell().innerText = g.people;
            row.insertCell().innerText = g.cars;
            row.insertCell().innerText = g.bla;
            row.insertCell().innerText = Math.round(g.area);
            row.insertCell().innerText = g.cells.length;
        });
    };

    window.getGroupBounds = function(g) {
        if (g.cells.length === 0) return map.getBounds();
        let merged = g.cells[0].geojson;
        for (let j = 1; j < g.cells.length; j++) merged = turf.union(merged, g.cells[j].geojson);
        return L.geoJSON(merged).getBounds();
    };

    // üåÑ –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–æ–Ω ‚Äî –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–Ø + –†–ï–õ–¨–ï–§
    window.assignZones = function() {
        if (gridCells.length === 0) return alert('–ì—Ä–∏–¥!');
        if (groups.length === 0) return alert('–ì—Ä—É–ø–ø—ã!');
        zoneLayers.clearLayers();
        groups.forEach(g => { g.cells = []; g.area = 0; });

        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–æ–≤ —è—á–µ–µ–∫
        const centers = gridCells.map(c => ({
            coords: c.center.geometry.coordinates,
            area: c.area,
            cell: c
        }));

        // –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–µ–ª—å–µ—Ñ ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º –≤–µ—Å –ø–æ –≤—ã—Å–æ—Ç–µ (—ç–º—É–ª—è—Ü–∏—è)
        centers.forEach(c => {
            // –≠–º—É–ª—è—Ü–∏—è —Ä–µ–ª—å–µ—Ñ–∞: —á–µ–º –≤—ã—à–µ ‚Äî —Ç–µ–º —Ç—è–∂–µ–ª–µ–µ (–¥–ª—è –ø—Ä–∏–º–µ—Ä–∞)
            const elevation = getElevationApprox(c.coords[1], c.coords[0]); //Á∫¨Â∫¶, ÁªèÂ∫¶
            c.elevationWeight = elevation > 200 ? 2 : 1; // >200–º ‚Äî –≤–¥–≤–æ–µ —Å–ª–æ–∂–Ω–µ–µ
        });

        // –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è k-means –ø–æ —Ü–µ–Ω—Ç—Ä–∞–º
        const clusters = kMeansClustering(centers, groups.length);

        // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —è—á–µ–π–∫–∏ –ø–æ –≥—Ä—É–ø–ø–∞–º
        groups.forEach((g, i) => {
            const cluster = clusters[i];
            if (!cluster) return;
            cluster.points.forEach(p => {
                g.cells.push(p.cell);
                g.area += p.area;
            });
        });

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
        gridCells.forEach(cell => {
            groups.forEach(g => {
                if (g.cells.includes(cell)) {
                    cell.layer.setStyle({fillColor: g.color, fillOpacity: 0.45, color: g.color, weight: 2, opacity: 0.9});
                }
            });
        });

        groups.forEach(g => {
            if (g.cells.length === 0) return;
            let merged = g.cells[0].geojson;
            for (let j = 1; j < g.cells.length; j++) merged = turf.union(merged, g.cells[j].geojson);
            const center = turf.center(merged);
            L.geoJSON(merged, {style: {color: g.color, weight: 6, fillOpacity: 0, dashArray: '10,15', opacity: 0.9}}).addTo(zoneLayers);
            L.marker(center.geometry.coordinates.slice().reverse(), {
                icon: L.divIcon({className: 'group-label', html: g.callsign, iconSize: [120,44], iconAnchor: [60,22]})
            }).addTo(zoneLayers);
        });

        updateGroupsTable();
        forceResize();
    };

    // üó∫Ô∏è –ü—Ä–æ—Å—Ç–∞—è —ç–º—É–ª—è—Ü–∏—è —Ä–µ–ª—å–µ—Ñ–∞ (–º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ API OpenTopography)
    function getElevationApprox(lat, lng) {
        // –ü—Ä–∏–º–µ—Ä: —Å–ª—É—á–∞–π–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –æ—Ç 100 –¥–æ 300 –º
        return 100 + Math.sin(lat * 0.1) * 100 + Math.cos(lng * 0.1) * 50;
    }

    // üìä K-Means –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è
    function kMeansClustering(points, k) {
        if (points.length < k) k = points.length;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤
        let centroids = [];
        for (let i = 0; i < k; i++) {
            centroids.push([...points[i].coords]);
        }

        let iterations = 0;
        const maxIterations = 100;
        let changed = true;

        while (changed && iterations < maxIterations) {
            iterations++;
            changed = false;

            // –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∫ –±–ª–∏–∂–∞–π—à–∏–º —Ü–µ–Ω—Ç—Ä–æ–∏–¥–∞–º
            const clusters = Array.from({ length: k }, () => ({ points: [] }));
            points.forEach(p => {
                let minDist = Infinity;
                let bestCluster = 0;
                for (let i = 0; i < k; i++) {
                    const dist = Math.sqrt(
                        Math.pow(p.coords[0] - centroids[i][0], 2) +
                        Math.pow(p.coords[1] - centroids[i][1], 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        bestCluster = i;
                    }
                }
                clusters[bestCluster].points.push(p);
            });

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤
            for (let i = 0; i < k; i++) {
                const cluster = clusters[i];
                if (cluster.points.length === 0) continue;

                let sumX = 0, sumY = 0;
                cluster.points.forEach(p => {
                    sumX += p.coords[0];
                    sumY += p.coords[1];
                });
                const newX = sumX / cluster.points.length;
                const newY = sumY / cluster.points.length;

                if (Math.abs(newX - centroids[i][0]) > 0.0001 || Math.abs(newY - centroids[i][1]) > 0.0001) {
                    changed = true;
                }
                centroids[i] = [newX, newY];
            }
        }

        return clusters;
    }

    // üõ£Ô∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤ ‚Äî —Ç–µ–ø–µ—Ä—å —Å —É—á—ë—Ç–æ–º –¥–æ—Ä–æ–≥ –∏ —Ç–∏–ø–∞ –≥—Ä—É–ø–ø—ã
    window.generateRoutes = function() {
        routeLayers.clearLayers();
        const stepPesh = parseFloat(document.getElementById('stepPesh').value) || 10;
        const stepBla = parseFloat(document.getElementById('stepBla').value) || 50;
        const blaSpeed = 10; // m/s
        const blaTimeMax = 25 * 60; // 25 min in sec

        groups.forEach(g => {
            if (g.cells.length === 0) return;

            let merged = g.cells[0].geojson;
            for (let j = 1; j < g.cells.length; j++) merged = turf.union(merged, g.cells[j].geojson);

            const bbox = turf.bbox(merged);
            const avgLat = (bbox[1] + bbox[3]) / 2;
            const metersPerDegLat = 111132.92 - 559.82 * Math.cos(2 * avgLat * Math.PI/180) + 1.175 * Math.cos(4 * avgLat * Math.PI/180);
            const stepDeg = (g.bla ? stepBla : stepPesh) / metersPerDegLat;

            let paths = [];
            let direction = 1;

            // –î–ª—è –≥—Ä—É–ø–ø —Å –∞–≤—Ç–æ ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–∞—Ä—à—Ä—É—Ç –ø–æ –¥–æ—Ä–æ–≥–∞–º
            if (g.cars > 0) {
                generateRouteByRoads(g, merged);
                return;
            }

            // –î–ª—è –ø–µ—à–∏—Ö –∏ –ë–õ–ê ‚Äî –æ–±—ã—á–Ω—ã–π –∑–∏–≥–∑–∞–≥
            for (let lat = bbox[1]; lat <= bbox[3]; lat += stepDeg) {
                let line = turf.lineString([[bbox[0], lat], [bbox[2], lat]]);
                let clipped = turf.lineIntersect(line, merged);
                if (clipped.features.length > 0) {
                    let coords = clipped.features[0].geometry.coordinates;
                    if (direction === -1) coords = coords.reverse();
                    paths.push(coords);
                    direction = -direction;
                }
            }

            if (paths.length === 0) return;

            let fullPath = paths[0];
            for (let i = 1; i < paths.length; i++) fullPath = fullPath.concat(paths[i]);

            const length = turf.length(turf.lineString(fullPath), {units: 'meters'});
            if (g.bla && length / blaSpeed > blaTimeMax) {
                console.warn(`BLA route too long for battery: ${g.callsign}`);
                return;
            }

            L.polyline(fullPath.map(c => [c[1], c[0]]), {color: g.color, weight: 3, dashArray: '5, 5'}).addTo(routeLayers);
        });
        forceResize();
    };

    // üöó –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞ –ø–æ –¥–æ—Ä–æ–≥–∞–º –¥–ª—è –≥—Ä—É–ø–ø —Å –∞–≤—Ç–æ
    function generateRouteByRoads(group, zoneGeoJSON) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–æ—Ä–æ–≥–∏ (roadLayer) –∏–ª–∏ –∏–º–∏—Ç–∏—Ä—É–µ–º
        const roads = [];
        roadLayer.eachLayer(layer => {
            if (layer instanceof L.Polyline) {
                roads.push(layer.toGeoJSON());
            }
        });

        if (roads.length === 0) {
            console.warn('No roads loaded ‚Äî using default zigzag');
            return;
        }

        // –ù–∞—Ö–æ–¥–∏–º –¥–æ—Ä–æ–≥–∏, –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–µ –∑–æ–Ω—É –≥—Ä—É–ø–ø—ã
        const intersectingRoads = [];
        roads.forEach(road => {
            try {
                const intersection = turf.intersect(road, zoneGeoJSON);
                if (intersection) {
                    intersectingRoads.push(intersection);
                }
            } catch (e) {
                console.warn('Road intersection error:', e.message);
            }
        });

        if (intersectingRoads.length === 0) {
            console.warn('No roads intersect group zone ‚Äî fallback to zigzag');
            return;
        }

        // –°–æ–∑–¥–∞—ë–º –µ–¥–∏–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –ø–æ –¥–æ—Ä–æ–≥–∞–º
        let combinedLine = null;
        intersectingRoads.forEach(road => {
            if (!combinedLine) {
                combinedLine = road;
            } else {
                try {
                    combinedLine = turf.union(combinedLine, road);
                } catch (e) {
                    console.warn('Union failed, skipping road');
                }
            }
        });

        if (combinedLine && combinedLine.geometry.type === 'LineString') {
            L.polyline(combinedLine.geometry.coordinates.map(c => [c[1], c[0]]), {
                color: group.color,
                weight: 3,
                dashArray: '5, 5'
            }).addTo(routeLayers);
            console.log(`Road route generated for group ${group.callsign}`);
        } else {
            console.warn('Failed to create road route');
        }
    }

    // üåê –ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Ä–æ–≥ (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚Äî –º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ Overpass API)
    function loadRoads() {
        // –£–ø—Ä–æ—â—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: —Ä–∏—Å—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–Ω—ã—Ö –¥–æ—Ä–æ–≥
        const exampleRoads = [
            [[53.91, 27.54], [53.90, 27.56]],
            [[53.905, 27.53], [53.905, 27.57]]
        ];

        exampleRoads.forEach(coords => {
            L.polyline(coords, { color: '#888', weight: 2, opacity: 0.7 }).addTo(roadLayer);
        });

        console.log('Roads loaded (example)');
    }

    window.exportGeoJSON = function() {
        const data = {type: "FeatureCollection", features: [searchFeature, ...gridCells.map(c => c.geojson), ...groups.map(g => {
            if (g.cells.length === 0) return null;
            let merged = g.cells[0].geojson;
            for (let j=1; j<g.cells.length; j++) merged = turf.union(merged, g.cells[j].geojson);
            merged.properties = {group: g.callsign, people: g.people, cars: g.cars, bla: g.bla};
            return merged;
        }).filter(Boolean)]};
        const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'pso_plan.geojson'; a.click();
    };

    window.exportKML = function() {
        const kml = new L.KML();
        drawnItems.eachLayer(l => kml.addLayer(l));
        gridLayer.eachLayer(l => kml.addLayer(l));
        zoneLayers.eachLayer(l => kml.addLayer(l));
        routeLayers.eachLayer(l => kml.addLayer(l));
        const blob = new Blob([kml.getKML()], {type: 'application/vnd.google-earth.kml+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'pso_plan.kml'; a.click();
    };

    window.saveProject = function() {
        const data = {searchFeature, gridCells: gridCells.map(c => c.geojson), groups};
        localStorage.setItem('psoProject', JSON.stringify(data));
        alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!');
    };

    window.loadProject = function() {
        const saved = localStorage.getItem('psoProject');
        if (saved && confirm('–ó–∞–≥—Ä—É–∑–∏—Ç—å?')) {
            const data = JSON.parse(saved);
            clearMap();
            searchFeature = data.searchFeature;
            alert('–ó–∞–≥—Ä—É–∂–µ–Ω–æ –±–∞–∑–æ–≤–æ ‚Äî –≥—Ä–∏–¥/–∑–æ–Ω—ã –ø–µ—Ä–µ—Å–æ–∑–¥–∞–π');
            forceResize();
        }
    };

    if (window.Telegram?.WebApp) {
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
        setTimeout(forceResize, 800);
    }

    forceResize();
    console.log('PSO MapBY Dfly v4.0 INIT COMPLETE ‚Äî with improved zoning and routing');
});
</script>
</body>
</html>
