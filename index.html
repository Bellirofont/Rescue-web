<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>PSO MapBY Dfly v1.0 — срочная итерация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman-free.css" />
    <style>
        body { margin:0; padding:0; font-family: Arial; }
        #map { position: absolute; top: 0; bottom: 0; left: 0; right: 0; }
        #sidebar { position: absolute; top: 10px; left: 10px; width: 340px; max-height: 90%; overflow-y: auto; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 12px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 1000; }
        button, input, select { margin: 5px 0; padding: 8px; width: 100%; border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #999; padding: 6px; text-align: center; font-size: 13px; }
        .grid-label { background: transparent; border: none; color: #000; font-weight: bold; font-size: 12px; text-shadow: 1px 1px 3px white; }
    </style>
</head>
<body>
<div id="map"></div>
<div id="sidebar">
    <h2>PSO Координатор</h2>
    <button onclick="clearAll()">Очистить всё</button>
    <hr>
    <div id="gridControls" style="display:none;">
        <h4>Грид</h4>
        <select id="gridPreset">
            <option value="100">100 м</option>
            <option value="150">150 м</option>
            <option value="200" selected>200 м</option>
            <option value="250">250 м</option>
            <option value="500">500 м</option>
            <option value="1000">1 км</option>
        </select>
        <input type="number" id="gridCustom" placeholder="Своё значение (м)">
        <button onclick="generateGrid()">Сгенерировать грид</button>
    </div>
    <hr>
    <h4>Группы</h4>
    <input id="baseCall" placeholder="База позывного (Трест)">
    <input type="number" id="startNum" placeholder="Стартовый №" value="1">
    <input type="number" id="people" placeholder="Людей" value="5">
    <input type="number" id="cars" placeholder="Авто" value="0">
    <label><input type="checkbox" id="hasBla"> БЛА</label>
    <button onclick="addGroup()">Добавить группу</button>
    <button onclick="assignZones()">Распределить зоны</button>
    <table id="groupsTable"><tr><th>Позывной</th><th>Люди</th><th>Авто</th><th>БЛА</th><th>Площадь м²</th><th>Квадратов</th></tr></table>
    <hr>
    <button onclick="exportGeoJSON()">Экспорт GeoJSON</button>
    <button onclick="exportKML()">Экспорт KML</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/clusters-kmeans@6.5.0"></script>
<script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman-free.min.js"></script>
<script src="https://unpkg.com/leaflet-kml@1.0.1/L.KML.min.js"></script>

<script>
    const map = L.map('map').setView([53.90, 27.55], 12);
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '&copy; OpenStreetMap'}).addTo(map);
    const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution: 'Esri'});
    const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {attribution: 'Google'});
    L.control.layers({'OSM': osm, 'ESRI Satellite': esri, 'Google Satellite': googleSat}).addTo(map);

    map.pm.addControls({position: 'topleft', drawMarker: false, drawCircleMarker: false, drawPolyline: false, drawRectangle: false, drawCircle: false, cutPolygon: false});

    const drawnItems = new L.FeatureGroup().addTo(map);
    let searchPolygon = null;
    let gridLayer = null;
    let zoneLayers = null;
    let gridCells = [];
    let groups = [];
    let callCounter = 1;
    const colors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999','#66c2a5'];

    map.on('pm:create', e => {
        if (e.layer instanceof L.Polygon && !e.layer.pm._isRectangle) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            searchPolygon = e.layer;
            document.getElementById('gridControls').style.display = 'block';
        }
    });

    function getColumnLabel(n) { // 0=A, 25=Z, 26=AA...
        let s = '';
        while (n >= 0) {
            s = String.fromCharCode(65 + (n % 26)) + s;
            n = Math.floor(n / 26) - 1;
        }
        return s;
    }

    function generateGrid() {
        if (!searchPolygon) return;
        if (gridLayer) gridLayer.clearLayers();
        gridLayer = L.layerGroup().addTo(map);
        gridCells = [];

        let size = parseFloat(document.getElementById('gridCustom').value) || parseFloat(document.getElementById('gridPreset').value);
        if (!size || size <= 0) return;

        const geojson = searchPolygon.toGeoJSON();
        const poly = geojson.geometry.type === 'Polygon' ? geojson.geometry : geojson.geometry.geometries[0];
        const bbox = turf.bbox(geojson);
        const avgLat = (bbox[1] + bbox[3]) / 2;
        const metersPerDegLat = 111132.92 - 559.82 * Math.cos(2 * avgLat * Math.PI/180) + 1.175 * Math.cos(4 * avgLat * Math.PI/180);
        const metersPerDegLon = 111412.84 * Math.cos(avgLat * Math.PI/180) - 93.5 * Math.cos(3 * avgLat * Math.PI/180);
        const degLat = size / metersPerDegLat;
        const degLon = size / metersPerDegLon;

        let startLon = bbox[0] - (bbox[0] % degLon) - degLon;
        let startLat = bbox[1] - (bbox[1] % degLat) - degLat;

        let col = 0;
        for (let lon = startLon; lon <= bbox[2] + degLon; lon += degLon) {
            let row = 1;
            for (let lat = startLat; lat <= bbox[3] + degLat; lat += degLat) {
                const cellPoly = turf.polygon([[[lon, lat], [lon + degLon, lat], [lon + degLon, lat + degLat], [lon, lat + degLat], [lon, lat]]]);
                const clipped = turf.intersect(cellPoly, poly);
                if (clipped) {
                    const area = turf.area(clipped);
                    const center = turf.center(clipped);
                    const label = getColumnLabel(col) + row;

                    clipped.properties = {label, area};
                    const layer = L.geoJSON(clipped, {style: {color: '#3388ff', weight: 1, fillOpacity: 0.05}}).addTo(gridLayer);
                    const icon = L.divIcon({className: 'grid-label', html: label, iconSize: [30,30], iconAnchor: [15,15]});
                    L.marker([center.geometry.coordinates[1], center.geometry.coordinates[0]], {icon}).addTo(gridLayer);

                    gridCells.push({geojson: clipped, layer, center: turf.point(center.geometry.coordinates), area});
                }
                row++;
            }
            col++;
        }
    }

    function addGroup() {
        const base = document.getElementById('baseCall').value.trim() || 'Group';
        let num = parseInt(document.getElementById('startNum').value) || callCounter;
        const callsign = `${base}-${num.toString().padStart(2,'0')}`;
        const people = parseInt(document.getElementById('people').value) || 0;
        const cars = parseInt(document.getElementById('cars').value) || 0;
        const bla = document.getElementById('hasBla').checked;

        groups.push({callsign, people, cars, bla, color: colors[groups.length % colors.length], cells: [], area: 0});
        callCounter = num + 1;
        updateGroupsTable();
    }

    function updateGroupsTable() {
        const table = document.getElementById('groupsTable');
        table.innerHTML = '<tr><th>Позывной</th><th>Люди</th><th>Авто</th><th>БЛА</th><th>Площадь м²</th><th>Квадратов</th></tr>';
        groups.forEach(g => {
            const row = table.insertRow();
            row.insertCell().innerText = g.callsign;
            row.insertCell().innerText = g.people;
            row.insertCell().innerText = g.cars;
            row.insertCell().innerText = g.bla ? 'Да' : 'Нет';
            row.insertCell().innerText = Math.round(g.area);
            row.insertCell().innerText = g.cells.length;
        });
    }

    function assignZones() {
        if (gridCells.length === 0 || groups.length === 0) return;
        if (zoneLayers) zoneLayers.clearLayers();
        zoneLayers = L.layerGroup().addTo(map);
        groups.forEach(g => { g.cells = []; g.area = 0; });

        const points = turf.featureCollection(gridCells.map(c => c.center));
        const clustered = turf.clustersKmeans(points, {numberOfClusters: groups.length});

        // Собираем кластеры
        const clusters = Array.from({length: groups.length}, () => ({cells: [], area: 0}));
        gridCells.forEach((cell, i) => {
            const cl = clustered.features[i].properties.cluster;
            clusters[cl].cells.push(cell);
            clusters[cl].area += cell.area;
        });

        // Сортируем группы: БЛА + люди
        groups.sort((a,b) => (b.bla ? 10000 : 0) + b.people - ((a.bla ? 10000 : 0) + a.people));
        // Сортируем кластеры по убыванию площади
        clusters.sort((a,b) => b.area - a.area);

        // Назначаем крупнейшие кластеры приоритетным группам
        clusters.forEach((cl, i) => {
            const g = groups[i];
            g.cells = cl.cells;
            g.area = cl.area;
        });

        // Окраска квадратов
        gridCells.forEach(cell => {
            groups.forEach(g => {
                if (g.cells.includes(cell)) {
                    cell.layer.setStyle({fillColor: g.color, fillOpacity: 0.4, color: '#000', weight: 1});
                }
            });
        });

        // Union зон + надпись позывного
        groups.forEach(g => {
            if (g.cells.length === 0) return;
            let merged = g.cells[0].geojson;
            for (let j = 1; j < g.cells.length; j++) {
                merged = turf.union(merged, g.cells[j].geojson);
            }
            L.geoJSON(merged, {
                style: {color: g.color, weight: 4, fillOpacity: 0, dashArray: '5,10'}
            }).bindTooltip(g.callsign, {permanent: true, direction: 'center', className: 'group-label'}).addTo(zoneLayers);
        });

        updateGroupsTable();
    }

    function exportGeoJSON() {
        const data = {type: "FeatureCollection", features: [
            searchPolygon.toGeoJSON(),
            ...gridCells.map(c => c.geojson),
            ...groups.map(g => {
                if (g.cells.length === 0) return null;
                let merged = g.cells[0].geojson;
                for (let j=1; j<g.cells.length; j++) merged = turf.union(merged, g.cells[j].geojson);
                merged.properties = {group: g.callsign, people: g.people, cars: g.cars, bla: g.bla};
                return merged;
            }).filter(Boolean)
        ]};
        const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'pso_plan.geojson'; a.click();
    }

    function exportKML() {
        const kml = new L.KML();
        kml.addLayer(drawnItems);
        if (gridLayer) kml.addLayer(gridLayer);
        if (zoneLayers) kml.addLayer(zoneLayers);
        const blob = new Blob([kml.getKML()], {type: 'application/vnd.google-earth.kml+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'pso_plan.kml'; a.click();
    }

    function clearAll() {
        if (confirm('Очистить всё?')) {
            drawnItems.clearLayers();
            if (gridLayer) gridLayer.clearLayers();
            if (zoneLayers) zoneLayers.clearLayers();
            gridCells = []; groups = []; callCounter = 1;
            searchPolygon = null;
            document.getElementById('gridControls').style.display = 'none';
            updateGroupsTable();
        }
    }
</script>
</body>
</html>
